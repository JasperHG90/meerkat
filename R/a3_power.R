## Functions for assignment 3, part I

#' Empirical power of a t-test
#'
#' This function takes a reference mean value, sample size, mean, standard deviation, significance level and computes the empirical power of R randomly drawn normally distributed samples with mean mu, standard deviation sd and sample size n. It then calculates R t.tests with reference to the
#'
#' @param ref_mu numeric. This is a value indicating the true value of the mean (or difference in means if you are performing a two sample test). See ?t.test() for more information
#' @param n numeric. sample size
#' @param mu mean value used to draw random normal samples. See ?rnorm() for more information
#' @param sd standard deviation used to draw random normal samples
#' @param alpha significance level
#' @param R number of replications
#' @param ... optional arguments. You may pass selected parameters from the t.test() function.
#'
#' @return list containing:
#' \itemize{
#'   \item{inputs: }{list. user input values}
#'   \item{data: }{matrix. values of R samples of size n with mean mu and standard deviation sd drawn from a normal distribution using rnorm()}
#'   \item{p_values: }{vector. resulting p-values of R tests comparing the samples against the reference mean ref_mu}
#'   \item{power: vector. power calculated by taking the proportion of p-values for which the value falls below or is equal to the significance level alpha}
#' }
#'
#' @seealso Rizzo, Maria L. 'Statistical Computing with R. Chapman and Hall/CRC, 2007'. (pp. 167-169)
#' @export
emp_power <- function(ref_mu, n, mu, sd, alpha=0.05, R = 1000, ...) {

  # Type checks
  if(!all(vapply(c(n, ref_mu, mu, sd, R), function(x) is(x)[1], "char") == "numeric")) {

    stop("Parameters 'n', 'ref_mu', 'mu', 'sd', 'R' must be numeric")

  }

  ## Check if experiment/control contain the right parameters and if legal

  ## Save inputs
  inputs <- list(
    "n" = n,
    "ref_mu" = ref_mu,
    "mu" = mu,
    "sd" = sd,
    "R" = R
  )

  ## Get optional params
  # (for t-test etc.)
  opts <- list(...)
  alternative <- ifelse("alternative" %in% names(opts), opts$alternative, "two.sided")

  # Checks
  if(!alternative %in% c('two.sided', 'less', 'greater')) {
    stop("'alternative' must be one of 'one.sided', 'less' or 'greater'. See '?t.test' for more information")
  }

  # Add to inputs
  inputs$alternative <- alternative

  ## Generate data
  data <- generate_data(n, mu, sd, R)

  ## Perform test R times
  test_out <- rep_t_test(data, R, ref_mu, alternative)

  # Check % of p-values <= confidence level
  power <- mean(test_out <= alpha)

  # Return
  list(
    "inputs" = inputs,
    "data" = data,
    "p_values" = test_out,
    "power" = power,
    "se" = sqrt((power * (1-power))/1000)
  )

}

# HELPER FUNCTIONS ----

# Generate a matrix of n rows and R columns. The matrix is populated with n * R values drawn from a random distribution using rnorm()
#
# @param n see emp_power()
# @param mu see emp_power()
# @param sd see emp_power()
# @param R see emp_power()
#
# @return matrix of size n x R containing (n x R) randomly drawn normally distributed values
generate_data <- function(n, mu, sd, R) {

  exp <- replicate(R, rnorm(n, mu, sd))

  # return
  return(exp)

}

# Perform R t-tests on randomly sampled data
#
# @param data matrix. generated by generate_data()
# @param R see emp_power()
# @param mu0 see ref_mu parameter under emp_power()
# @param alternative string. indicate whether you want two-sided or one-sided test
#
# @return vector containing p-values
rep_t_test <- function(data, R, mu0, alternative) {

  # Apply over data
  apply(data,2, function(x) {

    # Perform test
    tst <- t.test(x,
                  alternative=alternative,
                  mu = mu0)

    # Return results
    tst$p.value

  })

}
